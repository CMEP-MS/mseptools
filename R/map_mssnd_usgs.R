#' Map USGS Stations in the Mississippi Sound
#'
#' Creates an interactive map of USGS monitoring stations in the Mississippi Sound,
#' primarily in the state of Mississippi.
#'
#' @param stations A data frame of station metadata, typically the `stnInfo` data frame
#'   from the list generated by `get_mssnd_data()`. Must include columns `station_nm`,
#'   `site_no`, `dec_lat_va`, and `dec_lon_va`.
#' @param color_function Optional. A function for mapping station names to colors,
#'   such as one created by [leaflet::colorFactor()]. If not provided, a default
#'   palette will be generated using the khroma package "roma" palette.
#'
#' @return A `leaflet` map widget displaying the station locations.
#'
#' @details If the `stations` data frame does not include a `clean_nm` column, one
#'   will be generated using [clean_station_names()]. The map includes selectable
#'   tile layers (CartoDB Positron and Esri) and circle markers with popups displaying
#'   station names and USGS site numbers.
#'
#' @import leaflet
#' @importFrom khroma color
#' @importFrom dplyr mutate arrange
#' @importFrom forcats fct_inorder
#' @importFrom rlang .data
#' @export
#'
#' @examples
#' \dontrun{
#' data <- get_mssnd_data()
#' stnInfo <- data$stnInfo
#' map <- map_mssnd_usgs(stnInfo)
#' map  # display in Viewer
#' }

map_mssnd_usgs <- function(stations,
                           color_function = NULL){
    # stations should be stnInfo data frame from list generated by get_mssnd_data
    # color_function should be a color palette function, like colorFactor
    to_map <- stations

    # generate clean names if they don't already exist
    if(!exists("clean_nm", to_map)){
        to_map$clean_nm <- clean_station_names(to_map$station_nm)
    }

    # generate color palette if it wasn't provided
    if(is.null(color_function)){
        to_map <- dplyr::arrange(to_map, .data$clean_nm) |>
            dplyr::mutate(clean_nm = forcats::fct_inorder(.data$clean_nm))
        domain_vals <- levels(to_map$clean_nm)
        pal <- as.character(khroma::color("roma")(length(domain_vals)))
        color_function <- leaflet::colorFactor(palette = pal,
                                               domain = domain_vals)
    } else {
        # if it was provided, extract the domain values
        # Try to extract domain from provided color function
        if (!is.null(environment(color_function)$domain)) {
            domain_vals <- environment(color_function)$domain
        } else {
            # Fallback: infer from data (but order may not be guaranteed)
            domain_vals <- sort(unique(to_map$clean_nm))
        }
        # Ensure clean_nm is a factor with correct levels
        to_map$clean_nm <- factor(to_map$clean_nm, levels = domain_vals)
    }


    m <- leaflet::leaflet(to_map) |>
        leaflet::addProviderTiles(provider = leaflet::providers$CartoDB.Positron,
                                  group = "Positron (CartoDB)") |>
        leaflet::addProviderTiles(provider = leaflet::providers$Esri,
                                  group = "Esri") |>
        leaflet::addLayersControl(baseGroups = c("Positron (CartoDB)",
                                                 "Esri")) |>
        leaflet::addCircleMarkers(lng = ~dec_lon_va,
                                  lat = ~dec_lat_va,
                                  fillColor = ~color_function(clean_nm),
                                  color = "black",
                                  weight = 0.7,
                                  radius = 12,
                                  fillOpacity = 0.9,
                                  popup = ~paste0(station_nm, ", USGS-", site_no)) |>
        leaflet::addLegend(position = "bottomright",
                           colors = color_function(domain_vals),
                           labels = domain_vals,
                           opacity = 0.7)
    m

}
